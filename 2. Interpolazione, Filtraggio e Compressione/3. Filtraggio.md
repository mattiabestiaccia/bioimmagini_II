---
tags:
  - filtraggio
  - riduzione-rumore
  - convoluzione
  - smoothing
  - edge-detection
  - filtri-gaussiani
aliases:
  - Filtraggio
  - Riduzione Rumore
  - Convoluzione Spaziale
---

> [!nav]- Navigazione
> **Precedente:** [[2. Interpolazione|â† Interpolazione]] | [[../INDICE|ğŸ“‘ Indice]] | **Successivo:** [[4. Compressione|Compressione â†’]]

## Filtraggio delle Immagini Biomediche

Gli algoritmi di filtraggio consentono l'elaborazione dell'immagine biomedica in modo da modificarne le caratteristiche. Non Ã¨ banale definire in modo univoco cosa si intende per operazione di filtraggio dal punto di vista radiologico. Seguendo lâ€™approccio della computer vision, possiamo definire filtraggio una operazione che cambia il contenuto informativo dellâ€™immagine senza estrarre informazioni topologiche (in questo differente dal processo di segmentazione). Quindi un filtro potrÃ  evidenziare i contorni dellâ€™immagine, mentre un processo di segmentazione convertirÃ  i contorni evidenziati in una entitÃ  geometrica, come una curva o una maschera. Il filtraggio ha essenzialmente due possibili scopi: â€¢ Migliorare la visualizzazione dellâ€™immagine per ottimizzare lâ€™analisi visiva della stessa. â€¢ Predisporre lâ€™immagine per ottimizzare una elaborazione successiva, tipicamente una segmentazione. Per quanto riguarda il secondo punto, lâ€™operazione di filtraggio avviene tipicamente in modo trasparente rispetto allâ€™utente, che osserva solo il risultato dellâ€™operazione successiva che rappresenta il fine del processo di elaborazione. Il primo caso Ã¨ invece critico rispetto al processo diagnostico, in quanto un errore nellâ€™algoritmo di filtraggio puÃ² causare la perdita di informazione utile e fini clinici e quindi indurre un errore diagnostico. Lâ€™introduzione di algoritmi di filtraggio in fase diagnostica Ã¨ quindi effettuato con estrema cautela. Le operazioni di filtraggio sullâ€™immagine si possono classificare in tre categorie principali: â€¢ Puntuali: Unâ€™operazione puntuale opera solo sul singolo pixel dellâ€™immagine, trasformandolo in base ad una funzione g(v) dove v Ã¨ il valore dellâ€™intensitÃ  del pixel. Esempio di operazioni puntuali sono il negativo dellâ€™immagine e in generale le lookup table compresa lâ€™operazione di windowing e lâ€™applicazione della gamma function. In una operazione puntuale il valore del pixel sullâ€™immagine filtrata dipende solo dal valore dello stesso pixel nellâ€™immagine originale. â€¢ Locali: una operazione locale elabora un pixel in base al valore del pixel stesso e dei pixel circostanti. Esempio di operazione locale Ã¨ la convoluzione spaziale che vedremo in dettaglio nel seguito. â€¢ Globali: Le operazioni globali operano sullâ€™immagine nel suo complesso. Esempio di operazioni globali sono le operazioni sullâ€™istogramma, come lâ€™equalizzazione.

## Puntuali

Le operazioni puntuali sono equivalenti ad una trasformazione dei livelli di grigio. In pratica un livello di grigio v dellâ€™immagine viene trasformato in un nuovo livello u secondo una trasformazione u=t(v). t puÃ² essere utilmente codificata in una lookup-table, cioÃ¨ una tabella con una sola colonna ed un numero di righe uguale alla profonditÃ  dellâ€™immagine. Il vantaggio della lookup-table Ã¨ che il filtraggio puÃ² essere eseguito in modo molto efficiente da un punto di vista computazionale. Una volta definita la tabella come un array T di N elementi dove N sono i possibili valori che puÃ² assumere Imm con dimensioni uguali a quella di potenza di grigio livelli Vincenzo Positano Modulo Elaborazione delle Bioimmagini â€“ corso Bioimmagini 7 v, il valore di u sarÃ  semplicemente u=T(v), e quindi il nuovo valore di u verrÃ  computato senza nessuna operazione algebrica ma attraverso un semplice accesso in memoria. Le color map per la visualizzazione a falsi colori sono un esempio di una lookup-table a tre colonne dove la tripletta (R,G,B) Ã¨ data da (R,G,B) = LT(:,v) dove v Ã¨ il livello di grigio. Esempi di trasformazioni puntuali sono (si consideri una immagine a 256 livelli): 1. lâ€™inversione dei livelli di grigio u = (255-v) 2. il Windowing 3. le operazioni di tipo gamma u=vg 4. la binarizzazione. Viene decisa una soglia T e lâ€™immagine viene ridotta ad una immagine bimodale (u = A se v>T, u = B se v<T) La figura seguente riassume alcune operazioni di filtraggio puntuale. Come si osserva, una operazione di filtraggio puntuale puÃ² essere sempre espressa come una curva (non necessariamente continua) in un piano bidimensionale con due assi di dimensioni pari alla profonditÃ  dellâ€™immagine originale (in questo caso 255, 8 bit) e dellâ€™immagine filtrata (in questo caso normalizzata a 1).
Esaminiamo in dettaglio lâ€™operazione di Windowing che Ã¨ di cruciale importanza nella visualizzazione delle immagini biomediche. Una immagine biomedica Ã¨ in generale codificata su 16 bit, cioÃ¨ ogni pixel dellâ€™immagine puÃ² assumere 216= 65536 valori, corrispondenti ad altrettanti livelli di grigio. Di fatto il numero di livelli che vengono utilizzati Ã¨ piÃ¹ basso, ad esempio nella risonanza magnetica solitamente qualche migliaio. Ad ogni modo, gli strumenti di visualizzazione utilizzati nella pratica clinica, come schermi video tradizionali o LCD, sono in grado di visualizzare solo 256 livelli di grigio. Dâ€™altra parte, risoluzioni superiori sarebbero inutili in quanto lâ€™occhio umano Ã¨ in Vincenzo Positano Modulo Elaborazione delle Bioimmagini â€“ corso Bioimmagini 8 grado di distinguere un numero limitato di livelli di grigio contemporaneamente, dellâ€™ordine di qualche decina. PoichÃ© lâ€™occhio Ã¨ invece capace di separare un numero molto maggiore di colori diversi, la rappresentazione delle immagini in falsi colori, cioÃ¨ facendo corrispondere ad ogni livello di grigio un determinato colore attraverso una mappa prestabilita puÃ² essere utilizzata per caratterizzare immagini mediche. Questa tecnica trova perÃ² applicazione solo in medicina nucleare e nella creazione di mappe parametriche. Tutti gli strumenti di visualizzazione devono quindi affrontare il problema di rappresentare un numero di livelli di grigio superiore a quello che lo strumento di visualizzazione puÃ² sostenere. Le immagini visualizzate o stampate sono quindi fortemente caratterizzate dal modo in cui questo problema Ã¨ risolto, ed essendo la soluzione del problema tuttâ€™altro che univoca, bisogna tener conto del fatto che ogni immagine stampata o visualizzata su schermo puÃ² rappresentare solo parzialmente lâ€™informazione globale contenuta nei dati effettivamente acquisiti dallo scanner.
Il processo mediante il quale i livelli di grigio dellâ€™immagine reale vengono rappresentate sullo schermo o stampate viene solitamente detto windowing. I pixel che giacciono in un certo intervallo di valori (una finestra o window), che puÃ² essere impostato dallâ€™utente, vengono rappresentati utilizzando tutti i livelli disponibili (tipicamente 256). I valori al di sotto della finestra selezionata vengono tutti posti a zero, e verranno quindi rappresentati in nero. A tutti i valori superiori verrÃ  invece assegnato il valore massimo visualizzabile (tipicamente 255) e quindi essi appariranno bianchi. La Figura 2.2 mostra un esempio delle differenze di visualizzazione ottenibili attraverso diverse scelte della finestra da utilizzare. Nellâ€™immagine superiore i livelli di grigio vengono mappati in modo proporzionale. Quindi i livelli visualizzati (da 0 a 255, asse y) vengono ottenuti normalizzando i valori originali rispetto al valor massimo dellâ€™immagine originale. Nellâ€™immagine in basso Ã¨ stata effettuata una opportuna operazione di windowing per visualizzare al meglio la zona di interesse. Si puÃ² notare come alcune zone abbiano perso notevolmente di risoluzione a causa dello schiacciamento dei livelli di grigio relativi. Lâ€™operazione di Windowing Ã¨ implementata in tutte le stazioni radiografiche e viene tipicamente pilotata dal movimento del mouse. Ad esempio il movimento orizzontale del mouse puÃ² pilotare la larghezza della finestra e il movimento verticale la posizione del centro della finestra sullâ€™asse x. Comunque il metodo con cui viene implementato il filtraggio Ã¨ in realtÃ  molto raffinato e mira a permettere una regolazione del windowing veloce ma allo stesso tempo precisa. La transizione dal livello 0 al livello massimo della finestra non Ã¨ necessariamente lineare, ma puÃ² assumere varie forme. Il formato DICOM contiene alcuni parametri che pilotano lâ€™operazione di Windowing. Group Element Title Esempio [0028-0106] Smallest Image Pixel Value 0 [0028-0107] Largest Image Pixel Value 4177 [0028-0150] Window Centre 163 [0028-0151] Window Width 327 I primi due parametri, â€œSmallest Image Pixel Valueâ€ e â€œLargest Image Pixel Valueâ€ permettono di leggere il massimo e minimo valore dellâ€™immagine e di creare un funzione di windowing lineare, evitando di comprendere nellâ€™operazione di windowing valori al di fuori del campo di definizione dellâ€™immagine, anche se compresi nella massima profonditÃ  teorica. I parametri successivi â€œWindow Centreâ€ e â€œWindow Widthâ€ definiscono una finestra di Windowing da utilizzare nella visualizzazione dellâ€™immagine. Questa finestra viene tipicamente salvata nel DICOM al momento dellâ€™acquisizione in base ad una ottimizzazione fatta dal produttore. Il programma di visualizzazione leggerÃ  dal DICOM la finestra e produrrÃ  una visualizzazione iniziale dellâ€™immagine che lâ€™utente potrÃ  poi modificare. Come illustrato in Figura 2.3, lâ€™operazione di Windowing per quanto semplice in via di principio Ã¨ estremamente importante nella pratica clinica, e necessita quindi di una accurata implementazione. Vale la pena di notare che le lastre radiografiche tradizionali o le immagini digitali in formato standard (jpeg, tiff) allegate ad un referto elettronico rappresentano il prodotto di una precisa operazione di Windowing eseguita dal medico refertante, con lâ€™obiettivo di fornire la migliore informazione Vincenzo Positano Modulo Elaborazione delle Bioimmagini â€“ corso Bioimmagini 10 iconografica al paziente ed al medico inviante. Esse non hanno perÃ² valore legale, in quanto lâ€™operazione di Windowing puÃ² cancellare alcune componenti delle immagini se eseguita in modo inappropriato. Lâ€™unica fonte certa sono quindi le immagini digitali in formato DICOM, che vengono quindi immagazzinate e sempre piÃ¹ spesso consegnate al paziente su supporto digitale (tipicamente un DVD contenente un visualizzatore DICOM).

## Locali
Lâ€™operazione di base nel filtraggio locale delle immagini Ã¨ lâ€™operazione di convoluzione spaziale detta anche a finestra mobile. Definiamo una matrice KxK, detta anche kernel o nucleo del filtro. Di solito il kernel Ã¨ quadrato e di dimensioni dispari. Siano wij gli elementi del kernel e fmn gli elementi dellâ€™immagine di dimensioni MxN. Allora il punto gmn dellâ€™immagine filtrata sarÃ  dato da:
![[Pasted image 20251129163958.png]]
In pratica lâ€™operazione di convoluzione spaziale consiste nel far scorrere il kernel sullâ€™immagine e sostituire volta per volta il pixel dellâ€™immagine corrispondente al pixel centrale del kernel con un valore che Ã¨ la somma dei pixel dellâ€™immagine coperti dal kernel pesati per gli elementi del kernel stesso. Solitamente il kernel Ã¨ normalizzato, e quindi la somma degli elementi del kernel Ã¨ unitaria in modo da non mutare sostanzialmente la dinamica dellâ€™immagine dopo il filtraggio. Questo punto Ã¨ importante nellâ€™imaging medico in quanto il valore del segnale puÃ² avere un significato diagnostico (come nella TAC). Inoltre essendo le immagini codificate come interi a 16 bit mutare la dinamica puÃ² causare problemi di overflow numerico. Il risultato di unâ€™operazione di convoluzione spaziale Ã¨ unâ€™immagine di dimensione pari alla somma dellâ€™immagine piÃ¹ la dimensione del kernel. Solitamente si considera solo la parte centrale dellâ€™immagine risultante per ottenere una immagine delle stesse dimensioni dellâ€™immagine originale Lâ€™operazione di filtraggio spaziale Ã¨ implementata in MATALB come conv2 e con conv nel caso di filtraggio in 3D. Lâ€™opzione same consente di mantenere la dimensione dellâ€™immagine filtrata. In alternativa Ã¨ possibile usare la funzione imfilter che ha le stesse caratteristiche. I principali filtri possono essere definiti in modo automatico con la funzione fspecial. Cambiando il kernel, si possono ottenere i vari tipi di filtraggio. Il primo esempio Ã¨ il filtro di smoothing, che Ã¨ in grado di ridurre il rumore. Il filtro di smoothing KxK Ã¨ definito come:
![[Pasted image 20251129164011.png]]
Notiamo che per semplicitÃ  si preferisce esprimere il filtro con valori interi, spesso sottintendendo lâ€™operazione di normalizzazione che comunque viene sempre eseguita. Ã¥ Ã¥ + - =- + - =- - + - + = + + 2 1 2 1 2 1 2 1 2 1 , 2 , 1 k k i k k j k j k i gmn fm i n jw i, j 1 , = 2 " K Wi j Vincenzo Positano Modulo Elaborazione delle Bioimmagini â€“ corso Bioimmagini 12 Il filtro effettua una operazione di media mobile, sostituendo ad un pixel dellâ€™immagine il valore della media dei pixel in un intorno. Il filtro riduce efficacemente il rumore nelle regioni omogenee, mentre introduce un â€œammorbidimentoâ€ dei contorni nelle regioni di confine tra i pattern, cosa non desiderabile nelle immagini biomediche. I due effetti sono tanto piÃ¹ rilevanti quanto piÃ¹ Ã¨ grande il Kernel. Una variante del filtro a media mobile Ã¨ il filtro â€˜pillboxâ€™ (opzione â€˜diskâ€™ di fspecial) che Ã¨ un filtro a media mobile limitato ad una zona circolare:
Un altro esempio di filtri dedicati alla riduzione del rumore sono i filtri di tipo gaussiano, dove il kernel Ã¨ definito come una gaussiana bidimensionale. Un esempio di filtro gaussiano 3x3 Ã¨ quello in figura.
I filtri gaussiani riducono il rumore riducendo lâ€™effetto di sfuocaÏƒmento dellâ€™immagine. Esempi di filtri gaussiani con diversa deviazione standard sono:
Nel filtro gaussiano, la somma del valore del peso centrale Ã¨ maggiore degli altri e i pesi sono proporzionali alla distanza dal centro secondo lâ€™equazione della gaussiana. Un filtro gaussiano Ã¨ definito quindi da due fattori. Il primo Ã¨ la grandezza del kernel, il secondo Ã¨ il valore della deviazione standard Ïƒ che definisce il valore degli elementi del kernel stesso. Si noti che per Ïƒ molto piÃ¹ grande delle dimensioni del kernel il filtro gaussiano collassa in un filtro a media mobile, per Ïƒ molto piccolo si ottiene un kernel diverso da zero solo nel punto centrale che lascia lâ€™immagine inalterata. Come visto in precedenza, lâ€™effetto dei filtri di smoothing (media mobile o gaussiano) Ã¨ simile al partial volume effect (PVE) che avviene a livello di acquisizione. Tali filtri possono quindi essere utilizzati per simulare il PVE nel modello dellâ€™immagine biomedica. La i filtri a convoluzione spaziale possono essere applicati efficacemente anche per evidenziare i contorni in una immagine. Il gradiente di unâ€™immagine f(x,y) nel punto (x,y) Ã¨ il vettore:
![[Pasted image 20251129164048.png]]
Eâ€™ noto che il vettore gradiente punta nella direzione di massima velocitÃ  di variazione di f nei punti (x,y). Pertanto nel problema della rivelazione dei bordi Ã¨ importante lâ€™ampiezza di questo vettore data da:
![[Pasted image 20251129164100.png]]
dove lâ€™angolo Ã¨ misurato rispetto allâ€™asse x. Notare che il calcolo del gradiente di unâ€™immagine Ã¨ basato sul calcolo delle derivate df/dx e df/dy per ogni pixel dellâ€™immagine. Quindi il calcolo del gradiente di unâ€™immagine deve essere fatto in due passi utilizzando due kernel: uno per la direzione x ed uno per la direzione y (immagini 2D) o tre passi (immagini 3D). Eâ€™ possibile anche definire un gradiente temporale in caso di immagini 2D+T o 3D+T.  In calcolo del gradiente implica il calcolo del valore della derivata da campioni discreti vista la natura discreta delle immagini. La derivata puÃ² essere approssimata in diversi modi. Per una maschera 3x3 il modo piÃ¹ semplice Ã¨ il gradiente di Sobel: Lâ€™operazione di derivata basata sullâ€™operatore di Sobel Ã¨ data da:
![[Pasted image 20251129164144.png]]
Analogamente si puÃ² definire il Laplaciano che implementa la derivata seconda dellâ€™immagine:
![[Pasted image 20251129164156.png]]
Lâ€™immagine di gradiente ha la caratteristica di avere un valore elevato sui contorni dellâ€™immagine e valore nullo nelle regioni ad intensitÃ  costante. Per eliminare il problema di pixel negativi che possono essere introdotti dal filtro possiamo normalizzare lâ€™immagine o sommare un valore costante. Uno dei possibili usi dellâ€™immagine di gradiente/laplaciano Ã¨ di fungere da guida nel filtraggio con un filtro di smoothing, in pratica il filtraggio viene effettuato solo nelle regioni nelle quali il valore dellâ€™immagine di gradiente Ã¨ basso come vedremo in seguito. Se sommiamo allâ€™immagine il laplaciano abbiamo un filtro che produce una maggiore definizione dei contorni (sharpening operator):
![[Pasted image 20251129164211.png]]
In MATLAB i filtri derivativi sono ottenibili attraverso la funzione fspecial come giÃ  detto. Il gradiente puÃ² essere calcolato direttamente con la funzione imgradient. Questa funzione consente di calcolare il gradiente attraverso vari metodi di calcolo delle derivate: Method Description 'sobel' Sobel gradient operator (default) 'prewitt' Prewitt gradient operator 'central' Central difference gradient: dI/dx = (I(x+1) - I(x-1))/2 'intermediate' Intermediate difference gradient: dI/dx = I(x+1) - I(x) 'roberts' Roberts gradient operator e fornisce in uscita il modulo del gradiente e la sua direzione.


## Globali- equalizzazione istogramma

Un esempio di filtraggio globale dellâ€™immagine Ã¨ rappresentato della procedura di equalizzazione dellâ€™istogramma, che ha lo scopo di aumentare il contrasto percepito dellâ€™immagine. Nella procedura di equalizzazione lâ€™istogramma dellâ€™immagine viene modificato in modo da divenire costante. Quindi se consideriamo lâ€™immagine f con istogramma h(f), il filtro produrrÃ  una immagine g con istogramma h(g) tale che h(g) = C per tutti i valori di livello di grigio di g. Si ha chiaramente C = N/p dove N Ã¨ il numero di pixel dellâ€™immagine e p la profonditÃ  dellâ€™immagine stessa. Inoltre, deve essere conservato lâ€™ordinamento dei livelli di grigio, per cui se f1< f2 deve risultare g1<g2, quindi la trasformazione deve essere monotona.
In pratica il filtro deve trovare â€œlâ€™inversaâ€ dellâ€™istogramma di f, in modo che la funzione monotona T che caratterizza il filtro sia tale che:
![[Pasted image 20251129164732.png]]
![[Pasted image 20251129164738.png]]
Consideriamo il fantoccio TAC in figura ed il relativo istogramma (in blu). Per chiarezza Ã¨ stata eliminata la prima riga dellâ€™istogramma che risulta molto alta contenendo la zona di zero padding
![[Pasted image 20251129164801.png]]
La CFD relativa allâ€™istogramma Ã¨ visualizzata in rosso. Come si osserva la CDF Ã¨ â€œpiattaâ€ nelle regioni dove lâ€™istogramma ha valori bassi mentre cresce ripidamente dove lâ€™istogramma ha valori alti. Il filtro usa la CDF come â€œhash tableâ€ per definire la trasformazione implementata. Quindi ad esempio, i valori di livello di grigio dellâ€™immagine tra 2000 e 3000 verranno sostituiti da valori molto simili dati dal valore della CDF che varia lentamente tra i due picchi a 2000 e 3000, â€œappiattendoâ€ lâ€™istogramma. Lâ€™immagine filtrata risulta:
![[Pasted image 20251129164819.png]]
Si osserva come lâ€™equalizzazione â€œallarghiâ€ i picchi ed introduca una quantizzazione dei livelli di grigio concentrandoli nelle regioni a CDF costante. In MATLAB il filtro Ã¨ implementato dalla funzione histeq che perÃ² non funziona correttamente per immagini a 16 bit. Lâ€™esempio Ã¨ implementato nel file


## Filtri adattivi
I filtri visti finora agiscono nello stesso modo su tutta lâ€™immagine. Una classe di filtri piÃ¹ complessa Ã¨ quella dei filtri anisotropici, che funzionano in modo diverso in regioni diverse dellâ€™immagine. Questi filtri vengono detti anche adattivi in quanto adattano il loro comportamento sulla base del contenuto dellâ€™immagine. Tipicamente un filtro anisotropico utilizza una informazione di gradiente per localizzare i bordi dellâ€™immagine che devono essere preservati nellâ€™operazione di filtraggio. Il filtraggio viene modulato in base al valore locale del gradiente. Un esempio semplice di un filtro adattivo Ã¨ un filtro di smoothing che effettua lo smoothing solo dove il gradiente locale dellâ€™immagine Ã¨ inferiore ad un certo valore di soglia, mentre dove il valore Ã¨ superiore lascia lâ€™immagine inalterata. Nella pratica per realizzare un semplice filtro adattivo si computa il gradiente dellâ€™immagine I_OR attraverso un filtraggio locale come descritto in precedenza. Si ottiene cosÃ¬ una immagine G di dimensioni uguale allâ€™originale che contiene il gradiente dellâ€™immagine stessa. Stabilita una soglia Tg si applica a G un filtro binario puntuale con soglia Tg, ottenendo una immagine maskHG, che vale uno se il gradiente Ã¨ maggiore di Tg e zero altrove. Una immagine binaria di questo tipo Ã¨ spesso detta maschera (mask). Applicando un filtro puntuale di inversione a maskHG si ottiene la sua inversa maskLG, che rappresenta la maschera delle regioni dellâ€™immagine con gradiente inferiore o uguale a Tg. A questo punto si applica un filtraggio locale a media mobile (smoothing) o gaussiano allâ€™immagine I_OR ottenendo lâ€™immagine filtrata I_MM, dove lo smoothing Ã¨ applicato su tutta lâ€™immagine. Lâ€™immagine filtrata in modo adattivo I_FA si ottiene dalla formula:
![[Pasted image 20251129164246.png]]
Infatti essendo le due maschere mutuamente esclusive (la loro somma da uno su tutti i pixel) lâ€™immagine risultante Ã¨ uguale allâ€™immagine originale nelle zone ad alto gradiente ed alla immagine filtrata nelle zone a basso gradiente. Le prestazioni di un filtro adattivo cosÃ¬ realizzato dipendono ovviamente dal valore di Tg. Se Tg Ã¨ troppo alto alcuni contorni verranno sfumati, se Tg Ã¨ troppo basso regioni uniformi dellâ€™immagine non verranno filtrate. Per individuare il valore ottimo di Tg Ã¨ utile esprimere tale soglia in funzione delle statistiche del rumore associato allâ€™immagine. Facciamo riferimento ad un modello semplificato di immagine biomedica dove lâ€™immagine reale Ã¨ data dalla somma dellâ€™immagine reale e di rumore gaussiano con media nulla e deviazione standard Ïƒ
![[Pasted image 20251129164302.png]]
Su un pattern omogeneo dellâ€™immagine (dove vogliamo che venga applicato il filtro il segnale sarÃ  distribuito il modo gaussiano con media Sp (valore del segnale sul pattern) e deviazione standard Ïƒ. Il valore del gradiente sul pattern intuitivamente dipenderÃ  da Ïƒ e dal tipo di filtro utilizzato per calcolare le due componenti del gradiente stesso. Nel caso semplificato in cui si computi la derivata come differenza tra il valore di due pixel adiacenti (kernel [1 0 -1] ) il valore di Gx sara Ga(Sp, Ïƒ) â€“ Gb(Sp, Ïƒ) dove Ga e Gb sono due realizzazioni indipendenti di un processo gaussiano con media Sp e deviazione standard Ïƒ. Sapendo che il 95% dei valori generati da un processo gaussiano Ã¨ compreso nella finestra [-1.96Ïƒ, 1.96Ïƒ] approssimabile a [-2Ïƒ, 2Ïƒ] nel caso peggiore |Gx| potrÃ  assumere il valore 4Ïƒ e cosÃ¬ per Gy, dando un gradiente complessivo massimo G = |Gx| + |Gy| di 8Ïƒ. Si tratta evidentemente di un caso limite molto improbabile, specialmente nel caso che il kernel usato per computare il gradiente sia di dimensioni non ridottissime, ma che giustifica lâ€™idea di imporre:
![[Pasted image 20251129164322.png]]
Eliminando quindi la dipendenza di Tg dal rumore. Il valore di Ïƒ puÃ² essere calcolato in modo manuale o automatico utilizzando le tecniche viste nel calcolo del SNR e CNR. Il valore di k consente di regolare il funzionamento del filtro, il valore di k varia tipicamente tra 1 e 4. Un filtro adattivo cosÃ¬ definito ha lo svantaggio principale di transire in modo brusco dalla zona in cui viene effettuato lo smoothing alla zona in cui lâ€™immagine originale viene preservata, a causa dellâ€™utilizzo di un filtro a gradino. Lâ€™altro svantaggio Ã¨ di richiedere la definizione di k per stabilire la soglia. Unâ€™alternativa piÃ¹ evoluta Ã¨ rappresentata dal filtro di Wiener. In tale filtro (funzione wiener2 del MATLAB) si filtra lâ€™immagine con un filtro a media mobile come in precedenza, ottenendo IMM che rappresenta i valori della media locale per ogni pixel dellâ€™immagine. Si calcola poi la mappa della varianza locale IVAR calcolando la varianza sullo stesso kernel utilizzato dal filtro a media mobile. Lâ€™immagine filtrata risulta:
![[Pasted image 20251129164332.png]]
Se la varianza dellâ€™immagine Ã¨ uguale a quella del rumore (pattern uniforme) il secondo termine si annulla e lâ€™immagine risultante Ã¨ uguale a quella filtrata con il filtro a media mobile. Se IVAR Ã¨ molto grande rispetto al rumore dellâ€™immagine lâ€™immagine filtrata risulta uguale allâ€™immagine originale. Nei due casi estremi il filtro di Wiener si comporta quindi come il filtro adattivo visto prima. Il vantaggio del filtro di Wiener Ã¨ che gestisce in modo graduale la transizione tra le zone omogenee e le zone ad alto gradiente dove sono presenti i contorni. Inoltre non Ã¨ richiesto di definire il valore di k ma solo di valutare il rumore sullâ€™immagine Ïƒ. Un approccio possibile per valutare Ïƒ in modo automatico Ã¨ far scorrere sullâ€™immagine un kernel (ad esempio 5x5) e valutare il valore della deviazione standard SD sulla regione di immagine coperta dal kernel. In MATLAB questa operazione Ã¨ implementata dalla funzione stdfilt. Si otterranno quindi un numero di valori di SD uguale al numero di pixel dellâ€™immagine. Nelle regioni allâ€™interno dei pattern uniformi il valore della SD sarÃ  Ïƒ, almeno nel caso di rumore gaussiano additivo. Nelle regioni a cavallo di due pattern il valore di SD sarÃ  maggiore di Ïƒ.
![[Pasted image 20251129164348.png]]
In figura osserviamo una immagine formata da pattern omogenei con rumore gaussiano a media nulla e Ïƒ=10 e la corrispondente mappa della SD. Come si nota dalla figura il valore di SD sulla mappa Ã¨ massimo i corrispondenza dei bordi ed assume valori bassi e variabili nelle regioni omogenee. Questo Ã¨ confermato dallâ€™istogramma della mappa SD:
![[Pasted image 20251129164405.png]]
Che presenta un picco evidente in corrispondenza della SD misurata nelle zone omogenee con il massimo in corrispondenza della Ïƒ del rumore gaussiano imposto. Dalla mappa SD Ã¨ possibile quindi valutare il valore di Ïƒ utile per la configurazione del filtro adattivo. Lâ€™approccio piÃ¹ semplice trascura la SD delle regioni di transizione e stima Ïƒ come la media delle SD sulla mappa (nel caso in figura si ottiene Ïƒ = 11.4). Volendo eliminare gli outliers dovuti ai bordi Ã¨ preferibile computare la mediana della mappa SD (nel caso in figura si ottiene Ïƒ = 0.92). Un approccio piÃ¹ accurato estrae il primo picco dellâ€™istogramma e ne computa la posizione del massimo. Se il rumore non Ã¨ gaussiano si dovrÃ  tenere conto di ciÃ² nel calcolo di Ïƒ. Ad esempio nelle immagini MR ci attendiamo che lâ€™istogramma della SD map presenti due picchi, uno in corrispondenza dello sfondo ed un altro spostato a destra di un fattore 1.526 in corrispondenza alle regioni omogenee ad alto SNR. In questo caso il valore di Ïƒ andrÃ  valutato direttamente sul secondo picco o sul primo introducendo lâ€™opportuno fattore correttivo.

##Adaptive Template Filtering
Per â€œAdaptive Template Filteringâ€ si indica un filtraggio basato sulla scelta adattiva di un determinato template (cioÃ¨ un kernel di filtraggio) in base alle caratteristiche dellâ€™immagine sottostante. Una implementazione possibile Ã¨ quella proposta da C. B. Ahn. Lâ€™idea di base Ã¨ quella di avere una collezione di possibili template e di scegliere per ogni locazione dellâ€™immagine un particolare template ottimizzato. Lâ€™obiettivo dellâ€™algoritmo Ã¨ quello di migliorare lâ€™SNR evitando allo stesso tempo la perdita di definizione dei contorni. Il numero dei possibili template dipende dalla grandezza del template stesso ed Ã¨ dato da:
![[Pasted image 20251129164536.png]]
La scelta del template ottimo viene effettuata attraverso il calcolo di un opportuno indice. In particolare, viene calcolata la deviazione standard (SD) del valore dei pixel sul template, data da:
![[Pasted image 20251129164552.png]]
dove x(i,j) sono i valori dei pixel nel template, (k,l) sono le coordinate del pixel da computare (e quindi le coordinate del centro del template), Tj Ã¨ il template corrente e Nj Ã¨ la dimensione m del template Tj . Per ogni pixel dellâ€™immagine da filtrare, la SD viene calcolata per ogni possibile template. I template vengono divisi in due classi in base alla SD: I template con SD minore di una certa soglia (plane templates) e quelli con SD superiore alla soglia (edge templates). Se vengono riconosciuti uno o piÃ¹ plane template, viene scelto quello con dimensione maggiore. Se non ci sono plane template, viene selezionato lâ€™edge template con SD minima. In realtÃ  per diminuire i tempi di calcolo si procede esaminando i template in ordine di dimensione e fermandosi appena viene trovato un plane template. Nella sostanza lâ€™algoritmo individua per ogni pixel la distribuzione spaziale dei pixel circostanti â€œsimiliâ€ al pixel corrente, ed effettua lâ€™operazione di smoothing tenendo conto solo di detti pixel. Il punto fondamentale dellâ€™algoritmo Ã¨ la scelta della soglia sulla SD. Similmente a quanto visto in precedenza la soglia Ã¨ definita come:
![[Pasted image 20251129164603.png]]
dove Ã¨ la SD del rumore sullâ€™immagine e a Ã¨ un fattore di scala, che assume un valore tra 1.2 e 1.6. La stima di puÃ² essere effettuata come visto in precedenza per il filtro adattivo. ( ) ( ) ( ) 2 , 1 , ,, 1 j ijT kl xi j x kl m s Ã = Ã© Ã¹ - Ã« Ã» - Ã¥ ( ) ( ) , 1 , , j ijT x kl xi j m Ã = Ã¥ n t = as s n s n Vincenzo Positano Modulo Elaborazione delle Bioim
---

> [!nav]- Navigazione
> **Precedente:** [[2. Interpolazione|â† Interpolazione]] | [[../INDICE|ğŸ“‘ Indice]] | **Successivo:** [[4. Compressione|Compressione â†’]]
